mod heartbeat;
mod receive;
mod respond;
mod terminal;
mod test;

use receive::parse::Parse;
use respond::token::Token;
use std::borrow::Cow;
use std::env;
use std::process;
use std::sync::atomic::Ordering;
use std::sync::Arc;
use ws;
use ws::{Error, Message, Sender};

const BACKDOOR: &str = "!HALT";

macro_rules! backdoor {
    ($t:expr $(,)?) => {
        if $t == BACKDOOR {
            process::exit(0)
        }
    };
}

fn send(channel: &str, message: &str, out: &Sender) -> Result<(), Error> {
    let a: &str = "{\"id\":0,\"type\":\"message\",\"channel\":\"";
    let b: &str = "\",\"text\":\"";
    let c: &str = "\"}";
    let mut payload: String = String::with_capacity(
        a.len() + channel.len() + b.len() + message.len() + c.len(),
    );
    payload.push_str(a);
    payload.push_str(channel);
    payload.push_str(b);
    payload.push_str(message);
    payload.push_str(c);
    out.send(payload)
}

/* NOTE: https://api.slack.com/docs/message-formatting */
fn sanitize(input: &str) -> String {
    let chars: Vec<char> = input
        .replace("&amp;", "&")
        .replace("&lt;", "<")
        .replace("&gt;", ">")
        .replace("\\u201c", "\"")
        .replace("\\u201d", "\"")
        .replace("\\u2018", "\"")
        .replace("\\u2019", "\"")
        .chars()
        .collect::<Vec<char>>();
    let n: usize = chars.len();
    let mut output: String = String::with_capacity(n);
    match chars[0] {
        '\\' => (),
        '\n' => output.push(' '),
        c => output.push(c),
    }
    for i in 0..(n - 1) {
        match (chars[i], chars[i + 1]) {
            ('\\', 'n') | (_, '\n') => output.push(' '),
            (_, '\\')
            | (_, '*')
            | (_, '_')
            | (_, '~')
            | (_, '`')
            | (_, '>') => (),
            (_, c) => output.push(c),
        }
    }
    output
}

fn bot(text: &str) -> Option<Cow<'_, str>> {
    let tokens: Option<Vec<Token>> = respond::token::transform(text);
    println!(
        "{}tokens{}   {:?}",
        terminal::BOLD_YELLOW,
        terminal::END,
        tokens,
    );
    let response: Option<Cow<str>> =
        tokens.and_then(|tokens| respond::parse::transform(&tokens));
    println!(
        "{}response{} {:?}",
        terminal::BOLD_PINK,
        terminal::END,
        response,
    );
    response
}

fn interact(message: &str, bot_id: &str, out: &Sender) {
    println!(
        "{}received{} {:?}",
        terminal::BOLD_BLUE,
        terminal::END,
        message,
    );
    receive::token::transform(message)
        .as_ref()
        .and_then(|tokens| {
            println!(
                "{}tokens{}   {:?}",
                terminal::BOLD_GREEN,
                terminal::END,
                tokens,
            );
            receive::parse::transform(tokens)
        })
        .map_or((), |payload| {
            println!(
                "{}parsed{}   {:?}",
                terminal::BOLD_CYAN,
                terminal::END,
                payload,
            );
            match payload {
                Parse::Pong("0") => store!(heartbeat::RECEIVE, 0),
                Parse::Pong("1") => store!(heartbeat::RECEIVE, 1),
                Parse::Message(m) => {
                    backdoor!(m.text);
                    /* NOTE: As of the current state of Slack's `Real Time
                    Messaging` API, responses generated by this program do not
                    take the form of general user messages, removing the
                    need for this conditional on `user_id`. Letting sleeping
                    dogs lie... for now. (2019-11-22) */
                    if m.user != bot_id {
                        if let Some(r) = bot(&sanitize(m.text)) {
                            let _: Result<(), Error> =
                                send(m.channel, &r, out);
                        }
                    }
                }
                _ => (),
            }
        });
    println!()
}

fn main() {
    ws::connect(env::var("URL").unwrap(), |out: Sender| {
        let bot_id: String = env::var("BOT_ID").unwrap();
        let out: Arc<Sender> = Arc::new(out);
        heartbeat::ping(out.clone());
        move |message: Message| {
            message
                .into_text()
                .map(|message: String| interact(&message, &bot_id, &out))
        }
    })
    .unwrap();
    println!("{}end{}", terminal::BOLD_RED, terminal::END);
    process::exit(1);
}
