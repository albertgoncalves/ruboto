mod receive;
mod respond;
mod terminal;

use receive::parse::Parse;
use respond::token::Token;
use std::borrow::Cow;
use std::env;
use std::process;
use std::sync::{Arc, Mutex, MutexGuard};
use std::thread;
use std::time::Duration;
use ws;
use ws::{Error, Message, Sender};

const EXIT_SUCCESS: i32 = 0;
const EXIT_FAILURE: i32 = 1;
const BACKDOOR: &str = "!HALT";
const WAIT: u64 = 10;
const PING_0: &str = r#"{"id": 0, "type": "ping"}"#;
const PING_1: &str = r#"{"id": 1, "type": "ping"}"#;

macro_rules! backdoor {
    ($t:expr $(,)?) => {
        if $t == BACKDOOR {
            process::exit(EXIT_SUCCESS)
        }
    };
}

fn send(channel: &str, message: &str, out: &Sender) -> Result<(), Error> {
    let a: &str = "{\"id\":0,\"type\":\"message\",\"channel\":\"";
    let b: &str = "\",\"text\":\"";
    let c: &str = "\"}";
    let mut payload: String = String::with_capacity(
        a.len() + channel.len() + b.len() + message.len() + c.len(),
    );
    payload.push_str(a);
    payload.push_str(channel);
    payload.push_str(b);
    payload.push_str(message);
    payload.push_str(c);
    out.send(payload)
}

fn bot(text: &str) -> Option<Cow<'_, str>> {
    let tokens: Option<Vec<Token>> = respond::token::transform(text);
    println!(
        "{}tokens{}   {:?}",
        terminal::BOLD_YELLOW,
        terminal::END,
        tokens,
    );
    let response: Option<Cow<str>> =
        tokens.and_then(|tokens| respond::parse::transform(&tokens));
    println!(
        "{}response{} {:?}",
        terminal::BOLD_PINK,
        terminal::END,
        response,
    );
    response
}

macro_rules! print_ping {
    ($p:expr $(,)?) => {
        println!("{}ping{}     {:?}", terminal::BOLD_WHITE, terminal::END, $p)
    };
}

#[allow(clippy::similar_names)]
pub fn heartbeat(out: Arc<Sender>, mutex: Arc<Mutex<(u8, u8)>>) {
    thread::spawn(move || loop {
        thread::sleep(Duration::from_secs(WAIT));
        let mut ping_pong: MutexGuard<(u8, u8)> = mutex.lock().unwrap();
        let ping: u8 = (*ping_pong).0;
        let pong: u8 = (*ping_pong).1;
        if ping == pong {
            if ping == 0 {
                (*ping_pong).0 = 1;
                out.send(PING_1).unwrap();
                print_ping!(1);
            } else {
                (*ping_pong).0 = 0;
                out.send(PING_0).unwrap();
                print_ping!(0);
            }
        } else {
            process::exit(EXIT_FAILURE)
        }
    });
}

fn interact(
    message: &str,
    bot_id: &str,
    out: &Sender,
    mutex: &Arc<Mutex<(u8, u8)>>,
) {
    println!(
        "{}received{} {:?}",
        terminal::BOLD_BLUE,
        terminal::END,
        message,
    );
    receive::token::transform(message)
        .as_ref()
        .and_then(|tokens| {
            println!(
                "{}tokens{}   {:?}",
                terminal::BOLD_GREEN,
                terminal::END,
                tokens,
            );
            receive::parse::transform(tokens)
        })
        .map_or((), |payload| {
            println!(
                "{}parsed{}   {:?}",
                terminal::BOLD_CYAN,
                terminal::END,
                payload,
            );
            match payload {
                Parse::Pong("0") => {
                    let mut ping_pong: MutexGuard<(u8, u8)> =
                        mutex.lock().unwrap();
                    (*ping_pong).1 = 0;
                }
                Parse::Pong("1") => {
                    let mut ping_pong: MutexGuard<(u8, u8)> =
                        mutex.lock().unwrap();
                    (*ping_pong).1 = 1;
                }
                Parse::Message(m) => {
                    backdoor!(m.text);
                    /* NOTE: Responses generated by this program no longer take
                     * the form of general user messages, removing the need for
                     * this conditional on `user_id`. Leaving it in *just in
                     * case* though.
                     */
                    if m.user != bot_id {
                        if let Some(r) =
                            bot(&receive::sanitize::sanitize(m.text))
                        {
                            let _: Result<(), Error> =
                                send(m.channel, &r, out);
                        }
                    }
                }
                _ => (),
            }
        });
    println!()
}

fn main() {
    ws::connect(env::var("URL").unwrap(), |out: Sender| {
        let bot_id: String = env::var("BOT_ID").unwrap();
        let out: Arc<Sender> = Arc::new(out);
        let mutex: Arc<Mutex<(u8, u8)>> = Arc::new(Mutex::new((0, 0)));
        heartbeat(out.clone(), mutex.clone());
        move |message: Message| {
            message.into_text().map(|message: String| {
                interact(&message, &bot_id, &out, &mutex)
            })
        }
    })
    .unwrap();
    println!("{}end{}", terminal::BOLD_RED, terminal::END);
    process::exit(EXIT_FAILURE);
}
